<html>
<head>
    <title>Yestr user</title>
</head>

<body>

  <input type="button" value="Connect Metamask" id="connect_metamask_btn" />
  <span id="ethereum_address"></span>
  <br/>
  <br/>
  <input type="text" id="profile_name" />
  <br/>
  <textarea id="profile_about"></textarea>
  <br/>
  <input type="text" id="profile_pic_url" />
  <input type="button" value="Save" id="profile_save_btn" />
  <br/>
  <br/>

</body>


<script type="module">
import { ethers } from "/static/ethers-5.6.esm.min.js";
import { CHAIN_ID, CHAIN_NAME, RPC_URL, RELAY_URL} from "/static/config.js";

let params = new URLSearchParams(window.location.search);
for (let p of params.entries()) {
  console.log(p);
}
const user_id = params.get('addr');


const profile_name = document.getElementById('profile_name');
const profile_about = document.getElementById('profile_about');
const profile_pic_url = document.getElementById('profile_pic_url');
const profile_save_btn = document.getElementById('profile_save_btn');


window.onload = async () => {
  if (typeof window.ethereum !== 'undefined') {
    console.log('MetaMask is installed!');
    if(window.ethereum.isConnected()){
    }else{
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    }

    console.log(ethereum.selectedAddress);
    ethereum_address.innerText = ethereum.selectedAddress;

    connect_metamask_btn.onclick = async (evt) => {
      const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
      const account = accounts[0];
      console.log(account);
      ethereum_address.innerText = account;

      // try {
      //   await ethereum.request({
      //     method: "wallet_addEthereumChain",
      //     params: [{
      //       chainId: CHAIN_ID,
      //       rpcUrls: [RPC_URL],
      //       chainName: CHAIN_NAME,
      //       nativeCurrency: {
      //         name: "PoW",
      //         symbol: "POW",
      //         decimals: 0
      //       },
      //       blockExplorerUrls: [RPC_URL+"/scan"]
      //     }]
      //   });
      // } catch (error) {
      // }

      await ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: CHAIN_ID }],
      });
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();

    // Create WebSocket connection.
    const socket = new WebSocket(RELAY_URL);

    // Connection opened
    socket.addEventListener("open", (event) => {
      // const subscription_id = Math.random()*100000000000000000;
      // socket.send(JSON.stringify(["REQ", subscription_id, {"authors": [user_id]}]));
    });


    profile_save_btn.onclick = async (evt) => {
      console.log(profile_name.value);
      console.log(profile_about.value);
      console.log(profile_pic_url.value);
      const name = profile_name.value;
      const about = profile_about.value;
      const picture = profile_pic_url.value;

      const timestamp = parseInt(Date.now()/1000);
      const json = JSON.stringify([0, ethereum.selectedAddress, timestamp, 0, [], {name: name, about: about, picture: picture}]);
      console.log(json);
      const event_hash_id = ethers.utils.sha256(new TextEncoder().encode(json));

      const metadata_event = {
        "id": event_hash_id,
        "pubkey": ethereum.selectedAddress,
        "created_at": timestamp,
        "kind": 0,
        "tags": [],
        "content": {name: name, about: about, picture: picture},
      }

      if (name) {
        // console.log(ethers.utils.hexlify(new TextEncoder().encode(content.value)));
        const sig = await ethereum.request({
          method: "personal_sign",
          params: [ethers.utils.hexlify(new TextEncoder().encode(json)), ethereum.selectedAddress]
        });
        metadata_event['sig'] = sig;
        console.log(metadata_event);
        socket.send(JSON.stringify(['EVENT', metadata_event]));
      }else{
        // content_event_hash_id.innerText = 'empty!'
      }
    }

  }
}


</script>
</html>
